<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>3D City: thread_pool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">3D City<span id="projectnumber">&#160;v-1.0</span>
   </div>
   <div id="projectbrief">Computer Graphics Project</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classthread__pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classthread__pool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">thread_pool Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A C++17 thread pool class.  
 <a href="classthread__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc887e2c84ebe8176ce44a9065d780b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#afc887e2c84ebe8176ce44a9065d780b5">thread_pool</a> (const <a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> &amp;_thread_count=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:afc887e2c84ebe8176ce44a9065d780b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool.  <a href="classthread__pool.html#afc887e2c84ebe8176ce44a9065d780b5">More...</a><br /></td></tr>
<tr class="separator:afc887e2c84ebe8176ce44a9065d780b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d8f108fa2419441aba432f8ca98eae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#ac9d8f108fa2419441aba432f8ca98eae">~thread_pool</a> ()</td></tr>
<tr class="memdesc:ac9d8f108fa2419441aba432f8ca98eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the thread pool.  <a href="classthread__pool.html#ac9d8f108fa2419441aba432f8ca98eae">More...</a><br /></td></tr>
<tr class="separator:ac9d8f108fa2419441aba432f8ca98eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb577953c6d5f797a79b8ea5dc6ca2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthread__pool.html#ad74183606469099690be268f4a9ac099">ui64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#afcb577953c6d5f797a79b8ea5dc6ca2a">get_tasks_queued</a> () const</td></tr>
<tr class="memdesc:afcb577953c6d5f797a79b8ea5dc6ca2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently waiting in the queue to be executed by the threads.  <a href="classthread__pool.html#afcb577953c6d5f797a79b8ea5dc6ca2a">More...</a><br /></td></tr>
<tr class="separator:afcb577953c6d5f797a79b8ea5dc6ca2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b7074a626d50f846e75119421567f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#af2b7074a626d50f846e75119421567f1">get_tasks_running</a> () const</td></tr>
<tr class="memdesc:af2b7074a626d50f846e75119421567f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently being executed by the threads.  <a href="classthread__pool.html#af2b7074a626d50f846e75119421567f1">More...</a><br /></td></tr>
<tr class="separator:af2b7074a626d50f846e75119421567f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f208d87fb7cc624097b6316f65fac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#ac2f208d87fb7cc624097b6316f65fac4">get_tasks_total</a> () const</td></tr>
<tr class="memdesc:ac2f208d87fb7cc624097b6316f65fac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of unfinished tasks - either still in the queue, or running in a thread.  <a href="classthread__pool.html#ac2f208d87fb7cc624097b6316f65fac4">More...</a><br /></td></tr>
<tr class="separator:ac2f208d87fb7cc624097b6316f65fac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9878745e655fa3db5c7c16af9766fc59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a9878745e655fa3db5c7c16af9766fc59">get_thread_count</a> () const</td></tr>
<tr class="memdesc:a9878745e655fa3db5c7c16af9766fc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads in the pool.  <a href="classthread__pool.html#a9878745e655fa3db5c7c16af9766fc59">More...</a><br /></td></tr>
<tr class="separator:a9878745e655fa3db5c7c16af9766fc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9903782df9a91cfbc56f71ec3f596feb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F &gt; </td></tr>
<tr class="memitem:a9903782df9a91cfbc56f71ec3f596feb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a9903782df9a91cfbc56f71ec3f596feb">parallelize_loop</a> (const T1 &amp;first_index, const T2 &amp;index_after_last, const F &amp;loop, <a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> num_blocks=0)</td></tr>
<tr class="memdesc:a9903782df9a91cfbc56f71ec3f596feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by splitting it into blocks, submitting each block separately to the thread pool, and waiting for all blocks to finish executing.  <a href="classthread__pool.html#a9903782df9a91cfbc56f71ec3f596feb">More...</a><br /></td></tr>
<tr class="separator:a9903782df9a91cfbc56f71ec3f596feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9d8436b3eb525ae5fee597740a86f4"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a3e9d8436b3eb525ae5fee597740a86f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a3e9d8436b3eb525ae5fee597740a86f4">push_task</a> (const F &amp;task)</td></tr>
<tr class="memdesc:a3e9d8436b3eb525ae5fee597740a86f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a function with no arguments or return value into the task queue.  <a href="classthread__pool.html#a3e9d8436b3eb525ae5fee597740a86f4">More...</a><br /></td></tr>
<tr class="separator:a3e9d8436b3eb525ae5fee597740a86f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37f7cf895480503583a852c30947794"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A&gt; </td></tr>
<tr class="memitem:ae37f7cf895480503583a852c30947794"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthread__pool.html#ae37f7cf895480503583a852c30947794">push_task</a> (const F &amp;task, const A &amp;...args)</td></tr>
<tr class="memdesc:ae37f7cf895480503583a852c30947794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a function with arguments, but no return value, into the task queue.  <a href="classthread__pool.html#ae37f7cf895480503583a852c30947794">More...</a><br /></td></tr>
<tr class="separator:ae37f7cf895480503583a852c30947794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5926f83dde427afac052f4d72237b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#aa5926f83dde427afac052f4d72237b18">reset</a> (const <a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> &amp;_thread_count=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:aa5926f83dde427afac052f4d72237b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the number of threads in the pool.  <a href="classthread__pool.html#aa5926f83dde427afac052f4d72237b18">More...</a><br /></td></tr>
<tr class="separator:aa5926f83dde427afac052f4d72237b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132ec56ca21d1517b6851ab6d798ee0f"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A, typename  = std::enable_if_t&lt;std::is_void_v&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt;&gt;&gt; </td></tr>
<tr class="memitem:a132ec56ca21d1517b6851ab6d798ee0f"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a132ec56ca21d1517b6851ab6d798ee0f">submit</a> (const F &amp;task, const A &amp;...args)</td></tr>
<tr class="memdesc:a132ec56ca21d1517b6851ab6d798ee0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with zero or more arguments and no return value into the task queue, and get an std::future&lt;bool&gt; that will be set to true upon completion of the task.  <a href="classthread__pool.html#a132ec56ca21d1517b6851ab6d798ee0f">More...</a><br /></td></tr>
<tr class="separator:a132ec56ca21d1517b6851ab6d798ee0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c26beb0b0f6985b72ab98317ce9b09"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... A, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;, typename  = std::enable_if_t&lt;!std::is_void_v&lt;R&gt;&gt;&gt; </td></tr>
<tr class="memitem:a57c26beb0b0f6985b72ab98317ce9b09"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a57c26beb0b0f6985b72ab98317ce9b09">submit</a> (const F &amp;task, const A &amp;...args)</td></tr>
<tr class="memdesc:a57c26beb0b0f6985b72ab98317ce9b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with zero or more arguments and a return value into the task queue, and get a future for its eventual returned value.  <a href="classthread__pool.html#a57c26beb0b0f6985b72ab98317ce9b09">More...</a><br /></td></tr>
<tr class="separator:a57c26beb0b0f6985b72ab98317ce9b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887cef533635b8c52834b23be3ab1c68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a887cef533635b8c52834b23be3ab1c68">wait_for_tasks</a> ()</td></tr>
<tr class="memdesc:a887cef533635b8c52834b23be3ab1c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed.  <a href="classthread__pool.html#a887cef533635b8c52834b23be3ab1c68">More...</a><br /></td></tr>
<tr class="separator:a887cef533635b8c52834b23be3ab1c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a69128e62f8197d0ed578d6baa0553ce8"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a69128e62f8197d0ed578d6baa0553ce8">paused</a> = false</td></tr>
<tr class="memdesc:a69128e62f8197d0ed578d6baa0553ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable indicating to the workers to pause.  <a href="classthread__pool.html#a69128e62f8197d0ed578d6baa0553ce8">More...</a><br /></td></tr>
<tr class="separator:a69128e62f8197d0ed578d6baa0553ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bd5e834e1c8358cd24d2c5743b95a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#aa0bd5e834e1c8358cd24d2c5743b95a8">sleep_duration</a> = 1000</td></tr>
<tr class="memdesc:aa0bd5e834e1c8358cd24d2c5743b95a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The duration, in microseconds, that the worker function should sleep for when it cannot find any tasks in the queue.  <a href="classthread__pool.html#aa0bd5e834e1c8358cd24d2c5743b95a8">More...</a><br /></td></tr>
<tr class="separator:aa0bd5e834e1c8358cd24d2c5743b95a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a9a54befa558b9d426a5ef18118de6185"><td class="memItemLeft" align="right" valign="top">typedef std::uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a></td></tr>
<tr class="separator:a9a54befa558b9d426a5ef18118de6185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74183606469099690be268f4a9ac099"><td class="memItemLeft" align="right" valign="top">typedef std::uint_fast64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#ad74183606469099690be268f4a9ac099">ui64</a></td></tr>
<tr class="separator:ad74183606469099690be268f4a9ac099"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9c1e1a00bf0f12c5e4c1422d5eadca94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a9c1e1a00bf0f12c5e4c1422d5eadca94">create_threads</a> ()</td></tr>
<tr class="memdesc:a9c1e1a00bf0f12c5e4c1422d5eadca94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the threads in the pool and assign a worker to each thread.  <a href="classthread__pool.html#a9c1e1a00bf0f12c5e4c1422d5eadca94">More...</a><br /></td></tr>
<tr class="separator:a9c1e1a00bf0f12c5e4c1422d5eadca94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceb7a2d9745499649a4e32ea5fcb72b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a7ceb7a2d9745499649a4e32ea5fcb72b">destroy_threads</a> ()</td></tr>
<tr class="memdesc:a7ceb7a2d9745499649a4e32ea5fcb72b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the threads in the pool by joining them.  <a href="classthread__pool.html#a7ceb7a2d9745499649a4e32ea5fcb72b">More...</a><br /></td></tr>
<tr class="separator:a7ceb7a2d9745499649a4e32ea5fcb72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa156bf8fb5803cb0e56b4b5f4f6f2010"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#aa156bf8fb5803cb0e56b4b5f4f6f2010">pop_task</a> (std::function&lt; void()&gt; &amp;task)</td></tr>
<tr class="memdesc:aa156bf8fb5803cb0e56b4b5f4f6f2010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to pop a new task out of the queue.  <a href="classthread__pool.html#aa156bf8fb5803cb0e56b4b5f4f6f2010">More...</a><br /></td></tr>
<tr class="separator:aa156bf8fb5803cb0e56b4b5f4f6f2010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc980adc973c19cb64857b34e4759866"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#afc980adc973c19cb64857b34e4759866">sleep_or_yield</a> ()</td></tr>
<tr class="memdesc:afc980adc973c19cb64857b34e4759866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep for sleep_duration microseconds.  <a href="classthread__pool.html#afc980adc973c19cb64857b34e4759866">More...</a><br /></td></tr>
<tr class="separator:afc980adc973c19cb64857b34e4759866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b0cb91a6f87146fd8c194b3ee87638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a38b0cb91a6f87146fd8c194b3ee87638">worker</a> ()</td></tr>
<tr class="memdesc:a38b0cb91a6f87146fd8c194b3ee87638"><td class="mdescLeft">&#160;</td><td class="mdescRight">A worker function to be assigned to each thread in the pool.  <a href="classthread__pool.html#a38b0cb91a6f87146fd8c194b3ee87638">More...</a><br /></td></tr>
<tr class="separator:a38b0cb91a6f87146fd8c194b3ee87638"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afdf641af037cd483998f0f830d7db21f"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#afdf641af037cd483998f0f830d7db21f">queue_mutex</a> = {}</td></tr>
<tr class="memdesc:afdf641af037cd483998f0f830d7db21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex to synchronize access to the task queue by different threads.  <a href="classthread__pool.html#afdf641af037cd483998f0f830d7db21f">More...</a><br /></td></tr>
<tr class="separator:afdf641af037cd483998f0f830d7db21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25218460dba3f28dd14cade108ccbaa1"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a25218460dba3f28dd14cade108ccbaa1">running</a> = true</td></tr>
<tr class="memdesc:a25218460dba3f28dd14cade108ccbaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable indicating to the workers to keep running.  <a href="classthread__pool.html#a25218460dba3f28dd14cade108ccbaa1">More...</a><br /></td></tr>
<tr class="separator:a25218460dba3f28dd14cade108ccbaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aef9354f74dba9b469084ba17feb5e1"><td class="memItemLeft" align="right" valign="top">std::queue&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a0aef9354f74dba9b469084ba17feb5e1">tasks</a> = {}</td></tr>
<tr class="memdesc:a0aef9354f74dba9b469084ba17feb5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A queue of tasks to be executed by the threads.  <a href="classthread__pool.html#a0aef9354f74dba9b469084ba17feb5e1">More...</a><br /></td></tr>
<tr class="separator:a0aef9354f74dba9b469084ba17feb5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb87a055bf8762d9a6186d06db2730f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a4eb87a055bf8762d9a6186d06db2730f">thread_count</a></td></tr>
<tr class="memdesc:a4eb87a055bf8762d9a6186d06db2730f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of threads in the pool.  <a href="classthread__pool.html#a4eb87a055bf8762d9a6186d06db2730f">More...</a><br /></td></tr>
<tr class="separator:a4eb87a055bf8762d9a6186d06db2730f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c590c4b97bb05c59c22c40bbac43ed"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; std::thread[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#a59c590c4b97bb05c59c22c40bbac43ed">threads</a></td></tr>
<tr class="memdesc:a59c590c4b97bb05c59c22c40bbac43ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer to manage the memory allocated for the threads.  <a href="classthread__pool.html#a59c590c4b97bb05c59c22c40bbac43ed">More...</a><br /></td></tr>
<tr class="separator:a59c590c4b97bb05c59c22c40bbac43ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadd54679f33196ff289db30604a0032"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthread__pool.html#aaadd54679f33196ff289db30604a0032">tasks_total</a> = 0</td></tr>
<tr class="memdesc:aaadd54679f33196ff289db30604a0032"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic variable to keep track of the total number of unfinished tasks - either still in the queue, or running in a thread.  <a href="classthread__pool.html#aaadd54679f33196ff289db30604a0032">More...</a><br /></td></tr>
<tr class="separator:aaadd54679f33196ff289db30604a0032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A C++17 thread pool class. </p>
<p >The user submits tasks to be executed into a queue. Whenever a thread becomes available, it pops a task from the queue and executes it. Each task is automatically assigned a future, which can be used to wait for the task to finish executing and/or obtain its eventual return value. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00036">36</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9a54befa558b9d426a5ef18118de6185" name="a9a54befa558b9d426a5ef18118de6185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a54befa558b9d426a5ef18118de6185">&#9670;&nbsp;</a></span>ui32</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::uint_fast32_t <a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">thread_pool::ui32</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00037">37</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="ad74183606469099690be268f4a9ac099" name="ad74183606469099690be268f4a9ac099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74183606469099690be268f4a9ac099">&#9670;&nbsp;</a></span>ui64</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::uint_fast64_t <a class="el" href="classthread__pool.html#ad74183606469099690be268f4a9ac099">thread_pool::ui64</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00038">38</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc887e2c84ebe8176ce44a9065d780b5" name="afc887e2c84ebe8176ce44a9065d780b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc887e2c84ebe8176ce44a9065d780b5">&#9670;&nbsp;</a></span>thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> &amp;&#160;</td>
          <td class="paramname"><em>_thread_count</em> = <code>std::thread::hardware_concurrency()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_count</td><td>The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. With a hyperthreaded CPU, this will be twice the number of CPU cores. If the argument is zero, the default value will be used instead. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00050">50</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="ac9d8f108fa2419441aba432f8ca98eae" name="ac9d8f108fa2419441aba432f8ca98eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d8f108fa2419441aba432f8ca98eae">&#9670;&nbsp;</a></span>~thread_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_pool::~thread_pool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the thread pool. </p>
<p >Waits for all tasks to complete, then destroys all threads. Note that if the variable paused is set to true, then any tasks still in the queue will never be executed. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00058">58</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c1e1a00bf0f12c5e4c1422d5eadca94" name="a9c1e1a00bf0f12c5e4c1422d5eadca94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1e1a00bf0f12c5e4c1422d5eadca94">&#9670;&nbsp;</a></span>create_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::create_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the threads in the pool and assign a worker to each thread. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00291">291</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a7ceb7a2d9745499649a4e32ea5fcb72b" name="a7ceb7a2d9745499649a4e32ea5fcb72b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ceb7a2d9745499649a4e32ea5fcb72b">&#9670;&nbsp;</a></span>destroy_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::destroy_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the threads in the pool by joining them. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00300">300</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="afcb577953c6d5f797a79b8ea5dc6ca2a" name="afcb577953c6d5f797a79b8ea5dc6ca2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb577953c6d5f797a79b8ea5dc6ca2a">&#9670;&nbsp;</a></span>get_tasks_queued()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthread__pool.html#ad74183606469099690be268f4a9ac099">ui64</a> thread_pool::get_tasks_queued </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently waiting in the queue to be executed by the threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of queued tasks. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00073">73</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="af2b7074a626d50f846e75119421567f1" name="af2b7074a626d50f846e75119421567f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b7074a626d50f846e75119421567f1">&#9670;&nbsp;</a></span>get_tasks_running()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> thread_pool::get_tasks_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently being executed by the threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of running tasks. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00083">83</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="ac2f208d87fb7cc624097b6316f65fac4" name="ac2f208d87fb7cc624097b6316f65fac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f208d87fb7cc624097b6316f65fac4">&#9670;&nbsp;</a></span>get_tasks_total()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> thread_pool::get_tasks_total </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of unfinished tasks - either still in the queue, or running in a thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of tasks. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00092">92</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a9878745e655fa3db5c7c16af9766fc59" name="a9878745e655fa3db5c7c16af9766fc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9878745e655fa3db5c7c16af9766fc59">&#9670;&nbsp;</a></span>get_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> thread_pool::get_thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00101">101</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a9903782df9a91cfbc56f71ec3f596feb" name="a9903782df9a91cfbc56f71ec3f596feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9903782df9a91cfbc56f71ec3f596feb">&#9670;&nbsp;</a></span>parallelize_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::parallelize_loop </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by splitting it into blocks, submitting each block separately to the thread pool, and waiting for all blocks to finish executing. </p>
<p >The user supplies a loop function, which will be called once per block and should iterate over the block's range.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first index in the loop. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">T2</td><td>The type of the index after the last index in the loop. Should be a signed or unsigned integer. If T1 is not the same as T2, a common type will be automatically inferred. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from first_index to (index_after_last - 1) inclusive. In other words, it will be equivalent to "for (T i = first_index; i &lt; index_after_last; i++)". Note that if first_index == index_after_last, the function will terminate without doing anything. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. loop(start, end) should typically involve a loop of the form "for (T i = start; i &lt; end; i++)". </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is to use the number of threads in the pool. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00117">117</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="aa156bf8fb5803cb0e56b4b5f4f6f2010" name="aa156bf8fb5803cb0e56b4b5f4f6f2010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa156bf8fb5803cb0e56b4b5f4f6f2010">&#9670;&nbsp;</a></span>pop_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool thread_pool::pop_task </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to pop a new task out of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A reference to the task. Will be populated with a function if the queue is not empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a task was found, false if the queue is empty. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00312">312</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a3e9d8436b3eb525ae5fee597740a86f4" name="a3e9d8436b3eb525ae5fee597740a86f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e9d8436b3eb525ae5fee597740a86f4">&#9670;&nbsp;</a></span>push_task() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::push_task </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a function with no arguments or return value into the task queue. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to push. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00159">159</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="ae37f7cf895480503583a852c30947794" name="ae37f7cf895480503583a852c30947794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37f7cf895480503583a852c30947794">&#9670;&nbsp;</a></span>push_task() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::push_task </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a function with arguments, but no return value, into the task queue. </p>
<p >The function is wrapped inside a lambda in order to hide the arguments, as the tasks in the queue must be of type std::function&lt;void()&gt;, so they cannot have any arguments or return value. If no arguments are provided, the other overload will be used, in order to avoid the (slight) overhead of using a lambda.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to push. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00177">177</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="aa5926f83dde427afac052f4d72237b18" name="aa5926f83dde427afac052f4d72237b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5926f83dde427afac052f4d72237b18">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> &amp;&#160;</td>
          <td class="paramname"><em>_thread_count</em> = <code>std::thread::hardware_concurrency()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the number of threads in the pool. </p>
<p >Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_thread_count</td><td>The number of threads to use. The default value is the total number of hardware threads available, as reported by the implementation. With a hyperthreaded CPU, this will be twice the number of CPU cores. If the argument is zero, the default value will be used instead. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00186">186</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="afc980adc973c19cb64857b34e4759866" name="afc980adc973c19cb64857b34e4759866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc980adc973c19cb64857b34e4759866">&#9670;&nbsp;</a></span>sleep_or_yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::sleep_or_yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sleep for sleep_duration microseconds. </p>
<p >If that variable is set to zero, yield instead. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00327">327</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a132ec56ca21d1517b6851ab6d798ee0f" name="a132ec56ca21d1517b6851ab6d798ee0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132ec56ca21d1517b6851ab6d798ee0f">&#9670;&nbsp;</a></span>submit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A, typename  = std::enable_if_t&lt;std::is_void_v&lt;std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; bool &gt; thread_pool::submit </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with zero or more arguments and no return value into the task queue, and get an std::future&lt;bool&gt; that will be set to true upon completion of the task. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the zero or more arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">args</td><td>The zero or more arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to be used later to check if the function has finished its execution. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00209">209</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a57c26beb0b0f6985b72ab98317ce9b09" name="a57c26beb0b0f6985b72ab98317ce9b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c26beb0b0f6985b72ab98317ce9b09">&#9670;&nbsp;</a></span>submit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... A, typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, std::decay_t&lt;A&gt;...&gt;, typename  = std::enable_if_t&lt;!std::is_void_v&lt;R&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; R &gt; thread_pool::submit </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const A &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with zero or more arguments and a return value into the task queue, and get a future for its eventual returned value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">A</td><td>The types of the zero or more arguments to pass to the function. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">args</td><td>The zero or more arguments to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to be used later to obtain the function's returned value, waiting for it to finish its execution if needed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00237">237</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a887cef533635b8c52834b23be3ab1c68" name="a887cef533635b8c52834b23be3ab1c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887cef533635b8c52834b23be3ab1c68">&#9670;&nbsp;</a></span>wait_for_tasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::wait_for_tasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed. </p>
<p >Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the variable paused is set to true, this function only waits for the currently running tasks (otherwise it would wait forever). To wait for a specific task, use <a class="el" href="classthread__pool.html#a132ec56ca21d1517b6851ab6d798ee0f" title="Submit a function with zero or more arguments and no return value into the task queue,...">submit()</a> instead, and call the wait() member function of the generated future. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00256">256</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a38b0cb91a6f87146fd8c194b3ee87638" name="a38b0cb91a6f87146fd8c194b3ee87638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b0cb91a6f87146fd8c194b3ee87638">&#9670;&nbsp;</a></span>worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void thread_pool::worker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A worker function to be assigned to each thread in the pool. </p>
<p >Continuously pops tasks out of the queue and executes them, as long as the atomic variable running is set to true. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00337">337</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a69128e62f8197d0ed578d6baa0553ce8" name="a69128e62f8197d0ed578d6baa0553ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69128e62f8197d0ed578d6baa0553ce8">&#9670;&nbsp;</a></span>paused</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; thread_pool::paused = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An atomic variable indicating to the workers to pause. </p>
<p >When set to true, the workers temporarily stop popping new tasks out of the queue, although any tasks already executed will keep running until they are done. Set to false again to resume popping tasks. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00276">276</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="afdf641af037cd483998f0f830d7db21f" name="afdf641af037cd483998f0f830d7db21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf641af037cd483998f0f830d7db21f">&#9670;&nbsp;</a></span>queue_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex thread_pool::queue_mutex = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A mutex to synchronize access to the task queue by different threads. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00356">356</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a25218460dba3f28dd14cade108ccbaa1" name="a25218460dba3f28dd14cade108ccbaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25218460dba3f28dd14cade108ccbaa1">&#9670;&nbsp;</a></span>running</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; thread_pool::running = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An atomic variable indicating to the workers to keep running. </p>
<p >When set to false, the workers permanently stop working. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00361">361</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="aa0bd5e834e1c8358cd24d2c5743b95a8" name="aa0bd5e834e1c8358cd24d2c5743b95a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bd5e834e1c8358cd24d2c5743b95a8">&#9670;&nbsp;</a></span>sleep_duration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> thread_pool::sleep_duration = 1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The duration, in microseconds, that the worker function should sleep for when it cannot find any tasks in the queue. </p>
<p >If set to 0, then instead of sleeping, the worker function will execute std::this_thread::yield() if there are no tasks in the queue. The default value is 1000. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00281">281</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a0aef9354f74dba9b469084ba17feb5e1" name="a0aef9354f74dba9b469084ba17feb5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aef9354f74dba9b469084ba17feb5e1">&#9670;&nbsp;</a></span>tasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;std::function&lt;void()&gt; &gt; thread_pool::tasks = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A queue of tasks to be executed by the threads. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00366">366</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="aaadd54679f33196ff289db30604a0032" name="aaadd54679f33196ff289db30604a0032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadd54679f33196ff289db30604a0032">&#9670;&nbsp;</a></span>tasks_total</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a>&gt; thread_pool::tasks_total = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An atomic variable to keep track of the total number of unfinished tasks - either still in the queue, or running in a thread. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00381">381</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a4eb87a055bf8762d9a6186d06db2730f" name="a4eb87a055bf8762d9a6186d06db2730f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb87a055bf8762d9a6186d06db2730f">&#9670;&nbsp;</a></span>thread_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthread__pool.html#a9a54befa558b9d426a5ef18118de6185">ui32</a> thread_pool::thread_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of threads in the pool. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00371">371</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
<a id="a59c590c4b97bb05c59c22c40bbac43ed" name="a59c590c4b97bb05c59c22c40bbac43ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c590c4b97bb05c59c22c40bbac43ed">&#9670;&nbsp;</a></span>threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;std::thread[]&gt; thread_pool::threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A smart pointer to manage the memory allocated for the threads. </p>

<p class="definition">Definition at line <a class="el" href="thread__pool_8hpp_source.html#l00376">376</a> of file <a class="el" href="thread__pool_8hpp_source.html">thread_pool.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classthread__pool.html">thread_pool</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
